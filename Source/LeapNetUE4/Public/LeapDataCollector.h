// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "LeapNeuralData.h"
#include "Leap/include/LeapC.h"
#include "LeapMotion/Public/LeapMotionData.h"
#include "Kismet/KismetMathLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Math/Vector.h"
#include "LeapData_Structs.h"
#include "TimerManager.h"
#include "Engine/World.h"
#include "LeapDataCollector.generated.h"




UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class LEAPNETUE4_API ULeapDataCollector : public UActorComponent
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	ULeapDataCollector();

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;



#pragma region RecordingFunctions

	UFUNCTION(BlueprintCallable, CallInEditor)
		// Capture this frame's data
		void Snapshot();

	UFUNCTION(BlueprintCallable, CallInEditor)
		/** Removes last Snapshot data */
		void RemoveLastSnapshot();

	UFUNCTION(BlueprintCallable)
		/**
		* Removes up to the nth dataset from the end.
		* @param last - How far from the end to remove
		*/
		void RemoveLastNSnapshots(int last);

	UFUNCTION(BlueprintCallable, CallInEditor)
		// Starts recording the data continously
		void StartRecording();

	UFUNCTION(BlueprintCallable, CallInEditor)
		// Stops recording the data
		void StopRecording();

	UFUNCTION(BlueprintCallable, CallInEditor)
		// Saves the data to the slot
		void SaveRecording();

	UFUNCTION(BlueprintCallable, CallInEditor)
		// Deletes the most recent recording
		void DeleteRecording();

	UFUNCTION(BlueprintCallable, CallInEditor)
		// Sorts out the Gesture Index
		void GestureIndicesFromTags();

#pragma endregion

#pragma region Recording Properties

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		// Name of the slot to save the Leap Data to and load the data from
		FString slotName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		// Bool to control whether or not to overwrite the data in the save game
		bool overwriteData;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		// How many data samples are taken per second
		float recordRate = 1.f;


	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		// This is the name of the gesture that is currently active and will be attached to all recorded training data
		FString gestureName;

	UPROPERTY(BlueprintReadWrite)
		// The data sent by the Leap Motion Controller
		FLeapFrameData data;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		// The training data generated by the calculations to be sent to the save game and neural network
		TArray<FFrameData> trainingData;

	// Variable to keep track of the length of the recorded data so it's easy to remove if the user wishes to
	int recordingIterations;

	// Controls the recording functionality
	FTimerHandle recorderHandle;

#pragma endregion

#pragma region Saving And Loading

	// Leap Data save game
	class ULeapNeuralData* LeapData;

	UFUNCTION()
		/**
		* Saves the Leap Data generated from the Snapshot and Recording functions to a custom slot
		* @param customSlotName - The name of the slot to save the data to 
		* @param overwriteData - Whether or not to overwrite the data saved in the slot
		*/
		void SaveLeapData(FString customSlotName, bool overwriteTrainingData);

	UFUNCTION()
		/**
		* Loads the Leap Data given the slot name
		* @param customSlotName - The name of the slot to load from
		*/
		void LoadLeapData(FString customSlotName);

	UFUNCTION(CallInEditor)
		/*
		* Saves the Leap Data generated from Snapshot and Recording
		*/
		void SaveData() { SaveLeapData(this->slotName, this->overwriteData); }

	UFUNCTION(CallInEditor)
		/**
		* Loads the Leap Data
		*/
		void LoadData() { LoadLeapData(this->slotName); }


#pragma endregion

private:

#pragma region CalculateData

	UFUNCTION(BlueprintCallable)
		/**
		* Given the frame data generated from the leap motion controller, it will calculate the inputs to give to the neural network
		* @param frameData - The frame data to convert to an array of floats
		* @return Inputs to be fed into the neural network. Ensure that the length of this array is equal to the size of the input layer
		*/
		TArray<float> CalculateData(FLeapFrameData frameData);

	/**
	* Calculates the bone data as an array of floats. Provides the foundation for the data collection. Did this way to make it easy to change and optimise.
	* @param boneData - The LeapBoneData to calculate the floats for
	* @return - Array of floats that will make up the majority of the inputs for the network
	*/
	TArray<float> CalculateBoneData(FLeapBoneData boneData);

	/**
	* Calculates the Digit Data as an array of floats. Uses the CalculateBoneData function to calculate the data for the digit
	* @param digitData - The LeapDigitData to be used in the float calculation
	* @return - Array of floats to be used for this digit
	*/
	TArray<float> CalculateDigitData(FLeapDigitData digitData);

	/**
	* Calculates the Palm Data as an array of floats. Uses a custom function as it needs to extract different data
	* @param - palmData - The LeapPalmData to be used in the float calculation
	* @return - Array of floats to be used for this palm
	*/
	TArray<float> CalculatePalmData(FLeapPalmData palmData);

	/**
	* Calculates the Hand Data as an array of floats. Uses the CalculateDigitData and CalculatePalmData to get the data for the hand
	* @param handData - The LeapHandData to be used in this calculation
	* @return - Array of floats that are the total result of this hand's digits and it's palm
	*/
	TArray<float> CalculateHandData(FLeapHandData handData);

#pragma endregion

	FString test;



};
